#' Ratiometric analysis
#'
#' This function performs ratiometric analysis on 2 channels of the user's choosing.
#' Relies on data generated by micimportR.
#' @keywords microscopR
#' @export
#' @examples
#' fluoRatio()
fluoRatio <- function(x) {
  #Dependencies
  require("parallel")
  #set up parallel processing
   total_cores <- detectCores() - 1
   cl <- makeCluster(total_cores)
  #extract variables from generated list, make globally available
  images_list <<- micimportR_list$images_list
  imgmeta <<- micimportR_list$imgmeta
  folder_name <<- micimportR_list$folder_name
  #ask user to select channels for analysis
  chan1 <- as.numeric(readline(prompt = "What is the first channel index for analysis? "))
  chan2 <- as.numeric(readline(prompt = "What is the second channel index for analysis? "))
  #ask user if the dataset should be removed from the buffer after this function has finished
  dataset_checker()
  #export variables to each node in the cluster
  clusterExport(cl = cl, varlist = c("images_list", "imgmeta", "folder_name"))
  #initialize output vector
  mean_output <- vector("numeric", length = length(images_list))
  #define main loop for ratiometric analysis
  fluomainloop <- function(i, meta = imgmeta) {
    require("EBImage")
    require("data.table")
    require("parallel")
    #take image name from supplied metadata
    img_name <- meta[[i]]
    #make sure the image has at least 2 channels, otherwise skip to the next iteration
    if (numberOfFrames(images_list[[i]]) >= 2) {
      #if at least 2 channels are detected, export both to data frames
      chan1_df <- data.table(getFrame(images_list[[i]], chan1))
      chan2_df <- data.table(getFrame(images_list[[i]], chan2))
    } else {
      return("Only images with 2 channels or more can be analysed")
    }
    #scale up to 16 bit
    if (max(chan1_df, na.rm = TRUE) <= 1) {
      chan1_df <- chan1_df * 65536
      chan2_df <- chan2_df * 65536
    }
    #set all pixels with no signal to NA so they don't interfere with the analysis
    chan1_df[chan1_df < 1 & chan2_df < 1] <- NA
    chan1_df[chan1_df == 0] <- NA
    chan2_df[chan2_df == 0] <- NA
    #Calculate mean per channel
    chan1_mean <- mean(unlist(chan1_df), na.rm = TRUE)
    chan2_mean <- mean(unlist(chan2_df), na.rm = TRUE)
    #calculate the ratio between channels
    chan_ratio <- chan1_mean / chan2_mean
    #return ratio
    return(chan_ratio)
  }
  #all ratios of the dataset are outputted into a vector
  output <- parLapply(cl, seq_along(images_list), fluomainloop)
  #print vector to .txt
  sink(file = paste(folder_name, ".txt", sep = ""), type = "output")
  writeLines(as.character(output, con = stdout()))
  sink()
  #clean up variables
  rm(mean_output)
  dataset_remover()

}
